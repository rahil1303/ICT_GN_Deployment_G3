Build a mobile app (using Flutter or React Native) that serves visually impaired users in the Global North. The app must be WCAG 2.1 Level AAâ€“compliant, multilingual (English, Spanish, French), and modular. Focus on these high-level workflows as distinct functionalities, and apply the specified design choices throughout.

Technical Stack & Accessibility Foundations
Framework: Flutter or React Native for iOS and Android.

Accessibility APIs:

Screen-reader support (Semantics in Flutter; accessibilityLabel/accessibilityRole in RN).

Text-to-Speech via native TTS.

Voice input via Speech-to-Text (speech_to_text in Flutter; react-native-voice).

Haptic feedback (vibration patterns).

Theming & Layout:

Single-column, responsive layout; scalable fonts using relative units.

Default high-contrast theme (black text on yellow background or its dark-mode inverse). CSS variables or theme data for easy toggling.

Icons always paired with text labels and aria/accessibility labels.

Internationalization:

Resource files for English, Spanish, French.

On language change: update UI strings, TTS voice locale, voice recognition locale. Announce change via TTS.

Offline & Data Storage:

Local storage (SQLite/AsyncStorage) for saved journeys, tickets, preferences.

Graceful offline behavior: cached data for saved routes/tickets; TTS announcements when real-time unavailable.

Mock & Real APIs:

Abstract services for routing (GTFS or mock), real-time feed, boarding assistance notifications, exception reports.

Toggle mock mode for development/testing.

Voice & Focus Management:

Use ARIA live regions or equivalent to announce dynamic updates.

After navigation or modal, set focus and announce screen name and context.

Provide a persistent â€œVoice Commandâ€ activation button for commands like â€œGo to Plan Journeyâ€ or â€œRequest Assistance.â€

Functionalities (Distinct Workflows/Tabs)
1. Account & Subscription Management
Goal: Register/manage transit account, purchase and store passes.

Key Features & Design Choices:

Accessible Registration Form: Voice-driven field entry with TTS hints (â€œEnter emailâ€). Large-text fallback.

Subscription Purchase: List available passes with large text and TTS price announcements. Voice confirmation before purchase.

Pass Wallet: Show active passes via TTS on focus (â€œMonthly pass valid untilâ€¦â€). Voice command â€œActivate pass.â€

Expiry Notifications: TTS/vibration reminders for expiring passes.

Accessibility: All inputs labeled; error messages read aloud; keyboard/voice navigation; high-contrast UI.

2. Ticket Purchase & Validation
Goal: Buy tickets and ensure easy validation.

Key Features & Design Choices:

Ticket Purchase Flow: Voice selection of ticket type and fare zones; large buttons; TTS confirmation of cost.

Digital Ticket Storage: Cache ticket info locally; display QR/NFC placeholder plus TTS-readable ticket ID (â€œTicket ID: ABC123â€).

Validation Support: Auto-validate via geolocation or user tap â€œValidateâ€; TTS â€œTicket validated.â€ If tapping inaccessible, â€œNotify validatorâ€ triggers mock notification to driver with TTS feedback.

Offline Ticket Access: TTS â€œYour ticket is valid untilâ€¦â€ when offline.

Accessibility: Semantic components, voice commands (â€œValidate ticket nowâ€), haptic confirmation on validation.

3. Boarding the Correct Vehicle
Goal: Identify and board the correct bus/route, with assistance if needed.

Key Features & Design Choices:

Select or Plan Journey: User picks a saved journey or enters destination via voice/text; TTS reads summary.

Detect My Bus: Prominent button; on press, TTS â€œDetection started.â€ Use real-time feed + GPS (or mock) to announce approaching vehicles: ARIA live updates (â€œBus 19 arriving in 3 minâ€). Vibration: long pulse for correct bus, short for others.

Missed Boarding Fallback: If bus departs or detection times out: TTS â€œBus departed; next bus in 7 min. Switch?â€ Accept via voice/button.

Boarding Assistance Request: Within this workflow, a â€œRequest Boarding Assistanceâ€ button: accessible label, large, high-contrast. On tap: mock API call, TTS â€œDriver notified to assist your boarding,â€ vibration confirmation. After mock response: TTS â€œDriver acknowledged; be ready.â€

Accessibility: ARIA live regions announcing status; voice commands (â€œStart detectionâ€, â€œRequest assistanceâ€, â€œMissed busâ€); focus remains on actionable buttons; clear TTS feedback.

4. Check-in / Check-out & Exception Handling
Goal: Handle validation automatically and manage missed taps.

Key Features & Design Choices:

Auto Check-in: When detection confirms boarding, auto-validate: TTS â€œChecked in on Bus 19.â€

Auto Check-out: Geofencing or user tap â€œCheck outâ€: TTS â€œChecked out at Stop X.â€

Missed Validation Alert: If boarding detected without validation, TTS â€œIt seems you boarded without validating. Report?â€ Accept via voice/button.

Exception Report Flow: Accessible form: voice prompts to confirm date/time/route; TTS reads entries; on submit: mock API call, TTS â€œReport submitted.â€

Journey History: List past trips; each read via TTS when focused (â€œJune 10: Bus 19 from A to B; validatedâ€). For pending exceptions, TTS â€œReport pending.â€

Accessibility: Semantic form fields, voice-driven prompts, vibration feedback on submission, focus management when forms appear.

5. Journey Planning & Alternatives
Goal: Plan trips and adapt to real-time disruptions.

Key Features & Design Choices:

Trip Wizard: Voice input â€œPlan journey from home to hospital at 10 AM tomorrowâ€; fetch options via routing API or mock. Present options as large-text cards; TTS reads summary. Filters via voice/buttons (â€œFewer transfersâ€, â€œLow-floor vehicles onlyâ€).

Save Journeys: Accessible â€œSave journeyâ€ button with TTS confirmation.

Dynamic Rerouting: While en route, subscribe to real-time feed; if disruption, TTS â€œYour bus delayed; alternative: tram departing in 4 min. Switch?â€ Accept via voice/button.

Accessibility: ARIA live announcements for reroutes; voice commands for selection; haptic cues on important changes.

6. Notifications & Alerts
Goal: Keep users informed of service changes, personal reminders, emergencies.

Key Features & Design Choices:

Service Alerts: Subscribe to saved routes; on disruption, use Notification API plus in-app ARIA live: TTS â€œLine 19 suspended; plan alternative.â€ Vibration if critical.

Personal Reminders: Pass expiry, upcoming trips: TTS â€œJourney to clinic in 30 minutes.â€

Emergency Alerts: Severe weather/incidents: TTS/vibration: â€œAlert: severe weather on your route.â€

Accessibility: Notifications announced by screen reader; allow configuring alert types and frequency in Settings.

7. Support & Feedback
Goal: Provide accessible help and gather user feedback.

Key Features & Design Choices:

Help Center: Searchable FAQ via voice/text; large-text list; TTS reads Q&A on focus. Voice command â€œHow to request assistance?â€

Feedback Submission: Voice-record or accessible form (â€œDescribe issueâ€); TTS guidance and confirmation. Store locally and send when online.

Live Assistance: â€œCall Supportâ€ or â€œChat Supportâ€ mock flows; TTS instructions for dialing or chatting.

Accessibility: All controls labeled; voice navigation; ARIA live for responses.

8. Settings & Personalization
Goal: Let users configure language, accessibility, privacy, and mock modes.

Key Features & Design Choices:

Language Selection: English/Spanish/French toggle; on selection, TTS announces new language; update Recognition and TTS locale.

Accessibility Toggles: Speech rate slider with TTS preview; vibration intensity test; theme selector (high-contrast options).

Privacy/Data: Manage location permission with TTS explanation; clear stored data with confirmation.

Assistance Preferences: Predefine boarding assistance note (â€œI use wheelchairâ€); TTS confirms.

Development Toggles: â€œUse mock GTFS dataâ€, â€œSimulate driver responseâ€, â€œSimulate missed validation.â€ TTS announces toggle state.

Accessibility: Semantic controls, voice commands (â€œSet speech rate to 1.5xâ€), focus management after changes.

Implementation & Testing Guidance
Modular Services:

TransitService: fetch routes, real-time updates (real/mock).

VoiceService: wrap SpeechRecognition; handle errors with TTS fallback.

TTSService: centralized TTS calls with locale.

LocationService: geolocation, geofencing for check-in/out.

NotificationService: in-app and push notifications.

AssistanceService: mock boarding assistance API.

StorageService: manage local data (routes, tickets, history) securely.

Accessibility Utilities:

Hook or helper announce(text) that triggers ARIA live region update + TTS.

Focus management helpers to set focus after navigation or pop-ups.

Voice Command Handling:

Global â€œVoice Commandâ€ activation: use Web Speech API or native modules; map commands to navigation or actions. Provide TTS feedback on unrecognized commands.

Haptic Patterns:

Define consistent vibration patterns for: arrival alerts, validation success, assistance confirmation, errors. Ensure fallback to TTS if unsupported.

Offline Behavior:

Service Worker (PWA) or offline caching strategy in mobile. Announce offline status and degraded features. Queue actions (e.g., exception reports) to sync when online.

Internationalization:

Use i18n library; ensure all strings (UI, TTS prompts, errors, onboarding) are translated. On language switch, reinitialize voice recognition/synthesis with correct locale.

Onboarding Flow:

Implement a guided tutorial using sequential TTS messages and focus on elements: â€œThis is Plan Journey tab...â€, with skip and replay options.

Testing & Simulation:

Include toggles for mock data; provide sample JSON for GTFS-RT-like updates.

Instructions for testing with screen readers (VoiceOver/TalkBack).

Simulate voice inputs via pre-recorded phrases.

Test vibration patterns on devices/emulators.

Document steps to test each workflow end-to-end.

Deliverables
Complete project scaffold: organized into workflows/tabs matching the eight functionalities above.

UI components: semantic, accessible, high-contrast, large-text, labeled icons.

Services & contexts: modular code for voice/TTS, location, transit data, notifications, storage.

Multilingual resources: English, Spanish, French translations.

Mock endpoints & data: for routing, real-time updates, assistance requests, exception reports.

Accessibility annotations & comments: explain design decisions and justifications (e.g., reducing cognitive load, ensuring independence).

Onboarding tutorial code: TTS-driven walkthrough.

Testing guide: how to simulate real-time updates, test voice/TTS flows, screen-reader verification, offline scenarios.

Documentation: instructions to extend the app (adding languages, integrating real APIs, backend services).

ğŸ“ Note to Replit AI: Emphasize each high-level workflow as a distinct module/screen with clear entry points. Apply design choicesâ€”single-column, high contrast, scalable fonts, voice/haptic feedback, multilingual TTS/voice input, semantic accessibility propsâ€”consistently. Ensure the code is modular so developers can replace mocks with real services. Prioritize usability and independence for visually impaired users at every step.